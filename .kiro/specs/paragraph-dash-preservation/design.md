# Design Document

## Overview

Система сохранения тире в начале абзаца решает критическую проблему исчезновения тире при типографической обработке текста. Проблема возникала из-за агрессивных паттернов финальной очистки, которые удаляли тире вместе с пробельными символами после символа абзаца (¶).

Решение основано на модификации регулярных выражений в финальной стадии обработки с использованием положительных lookahead-утверждений для предотвращения удаления содержательных символов.

## Architecture

### Компоненты системы

```
TextProcessorRU
    ↓
applySortedRules()
    ↓
RUSSIAN_TYPOGRAPHY_RULES (приоритетная обработка)
    ↓
Финальная очистка с защитой тире
```

### Поток обработки

1. **Преобразование переносов строк** (приоритет 100): `\n` → `¶`
2. **Нормализация тире в начале абзаца** (приоритет 101): различные тире → эм-тире
3. **Защищенная финальная очистка** (приоритет 999): удаление лишних пробелов с сохранением содержимого

## Components and Interfaces

### TypographyRule Interface

```typescript
interface TypographyRule {
  name: string;
  priority: number;
  pattern: RegExp;
  replacement: string | ((match: string, ...groups: string[]) => string);
  description: string;
}
```

### Ключевые правила для сохранения тире

#### 1. Правило нормализации тире в начале абзаца
```typescript
{
  name: 'paragraph_start_dash_to_em',
  priority: 101,
  pattern: /¶(\t*)[ \u00A0]*(?:--|–|-)[ \u00A0]*/g,
  replacement: `¶$1${TC.EM_DASH} `,
  description: 'После преобразования переносов в ¶, в начале абзаца приводим дефисы/тире к эм-тире с пробелом'
}
```

#### 2. Защищенная финальная очистка
```typescript
{
  name: 'clean_spaces_after_paragraph',
  priority: 999,
  pattern: /¶ +/g,
  replacement: '¶',
  description: 'Удаление простых пробелов после символа абзаца (выполняется в самом конце)'
}
```

### Критические паттерны защиты

В функции `applySortedRules()` используются защищенные паттерны:

```typescript
// Защищенная очистка - только множественные пробелы
result = result.replace(/¶[ \t\u00A0\u2009]+(?=[ \t\u00A0\u2009])/g, '¶');

// Защищенная очистка с сохранением табуляций
result = result.replace(/¶(\t*)[ \u00A0\u2009]+(?=[ \t\u00A0\u2009])/g, '¶$1');
```

**Ключевая особенность**: Положительное lookahead-утверждение `(?=[ \t\u00A0\u2009])` гарантирует, что паттерн сработает только если после пробельных символов следуют еще пробельные символы, а не содержательные символы как тире.

## Data Models

### Типы тире в системе

```typescript
// Из TypographyConstants.ts
const EM_DASH = '—';        // U+2014 (основной тип для начала абзаца)
const EN_DASH = '–';        // U+2013 (для диапазонов)
const NON_BREAKING_HYPHEN = '‑'; // U+2011 (для составных слов)
```

### Состояния обработки тире

1. **Входные варианты**: `-`, `--`, `–`, `—`
2. **Промежуточное состояние**: после символа абзаца `¶`
3. **Финальное состояние**: нормализованное эм-тире `—` с правильными пробелами

## Error Handling

### Типы ошибок и их обработка

1. **Исчезновение тире**: Предотвращается защищенными паттернами финальной очистки
2. **Неправильная нормализация**: Контролируется приоритетами правил
3. **Конфликты между правилами**: Решаются через систему приоритетов

### Механизмы защиты

```typescript
// Проверка на бесконечные циклы
if (result === prevResult) {
  continue;
}

// Дедупликация для предотвращения повторов
const normalizeForCompare = (s: string) => s
  .replace(/[\u00A0\u2009]/g, ' ')
  .replace(/[\s\t\f\v]+/g, ' ')
  .trim();
```

## Testing Strategy

### Уровни тестирования

#### 1. Unit Tests
- Тестирование отдельных правил типографии
- Проверка корректности паттернов регулярных выражений
- Валидация приоритетов правил

#### 2. Integration Tests
- Тестирование полного цикла обработки текста
- Проверка взаимодействия между правилами
- Тестирование граничных случаев

#### 3. Regression Tests
- Специфические тесты для проблемы исчезновения тире
- Тестирование различных входных форматов
- Проверка сохранения тире в сложных документах

### Тестовые сценарии

```typescript
// Базовые случаи
"– Привет\n– Как дела?" → "— Привет¶— Как дела?"

// Граничные случаи
"¶– Привет" → "¶— Привет"
"¶ – Привет" → "¶— Привет"
"¶  – Привет" → "¶— Привет"

// Сложные случаи
"– Первый\n\n– Второй" → "— Первый¶¶— Второй"
```

### Критерии успеха

1. **Сохранение количества тире**: Входное количество тире = выходное количество эм-тире
2. **Правильное позиционирование**: Тире остается в начале абзаца
3. **Корректное форматирование**: Один пробел после тире
4. **Отсутствие побочных эффектов**: Другие типографические правила работают корректно

## Performance Considerations

### Оптимизации

1. **Кеширование правил**: `CACHED_SORTED_RULES` для избежания повторной сортировки
2. **LRU Cache**: Кеширование результатов обработки в `TextProcessor`
3. **Однократное применение**: Каждое правило применяется только один раз

### Сложность алгоритма

- **Временная сложность**: O(n × m), где n - длина текста, m - количество правил
- **Пространственная сложность**: O(n) для хранения промежуточных результатов

## Security Considerations

### Защита от ReDoS атак

- Все регулярные выражения проверены на отсутствие катастрофического backtracking
- Использование атомарных групп и possessive quantifiers где необходимо
- Ограничение размера входного текста через LRU cache

### Валидация входных данных

```typescript
if (!text || typeof text !== 'string') {
  throw new Error('Input must be a non-empty string');
}
```